# 아키텍처

도메인 주도 설계에서 아키텍처는 결코 주역이 아니다.

## 안티패턴 : 스마트 UI

- 화면
  - 주문 확인 화면
  - 주문 이력 목록 화면
  - 이전 주문 확인 화면

화면 마다 `주문 합계 금액`이 필요하다. 이러한 비지니스 로직을 UI 에 작성하게되면 문제가 많이 생긴다.

합계 금액을 계산하는 방법이 바뀌면, 코드를 세 군데나 수정해야 하며, 나중에 화면이 추가되면 또 중복코드를 작성해야 한다.

__사용자 인터페이스에 비지니스 로직을 구현하는 일은 없어야 한다.__

## 도메인 주도 설계가 아키텍처에게 원하는 것

아키텍처는 간단히 말해 코드를 구성하는 원칙이다. 어떤 내용을 구현한 코드가 어디에 배치되어야 하는지에 대한 답을 명확히 제시하며 로직이 무질서하게 흩어지는 것을 막는다.
개발자는 아키텍처가 제시하는 원칙에 따르면서 `어떤 로직을 어디에 구현할 것인지`에 대한 고민을 하지 않아도 된다. 이것은 개발자가 도메인 주도 설계의 본질인
`도메인을 잘 파악하고 잘 표현하는 것`에 집중 할 수 있게 해준다.

즉, 도메인 주도 설계에서 아키텍처의 역할은 __도메인 객체가 서로 얽힌 레이어를 분리해 소프트웨어 구현에 필요한 사정으로부터 도메인 객체를 지켜내는 것이다.__

## 아키텍처

- 계층형 아키텍처
- 헥사고날 아키텍처
- 클린 아키텍처
- 기타 등등

### 계층형 아키텍처

계층형 아키텍처는 다음과 같이 구성된다.

- 프레젠테이션 계층(사용자 인터페이스)
  - `컨트롤러`
- 애플리케이션 계층
  - `애플리케이션 서비스`
  - 도메인 계층의 요소를 지휘하는 요소가 모인 계층
  - 문제를 해결하기 위해 도메인 객체의 과업을 진행하고 관리
  - 도메인 규칙이나 동작을 직접 구현해서는 안된다
- 도메인 계층
  - `엔티티`
  - `도메인 서비스`
  - `명세`
- 인프라스트럭처 계층
  - 기술적 기반에 대한 접근을 제공
  - 애플리케이션을 위한 메시지 송신, 도메인을 위한 퍼시스턴시 제공 모듈
  - `ORM Mapper`

__의존의 방향은 위에서 아래로 흐른다.__

계층형 아키텍처가 적용된 패턴 중 하나가 바로 `MVC` 패턴이다.

### 헥사고날 아키텍처

헥사고날 아키텍처(hexagonal architecture)는 육각형이 모티브인 아키텍처이다. 

아키텍처 Concept 은 애플리케이션과 그 외 인터페이스나 저장 매체를 자유롭게 탈착 가능하게 하는 것이다.

애플리케이션 외의 모듈은 마치 게임 컨트롤러처럼 다른 것으로 바꿔 끼울 수 있는 요소다.

헥사고날 아키텍처는 어댑터가 포터 모양만 맞으면 동작하는 것과 같다고해서 `포트앤어댑터(port and adpaters)` 라고 부르기도 한다.

애플리케이션에 대한 입력을 받는 포트 어댑터를 `프라이머리 포트, 프라이머리 어댑터`라고 부른다. 반대로 애플리케이션이 외부와 상호작용하는 포트를 `세컨더리 포트`라고 하며, 이를 구현한 객체를
`세컨더리 어댑터`라고 한다.

```java
public class UserApplicationService {
  
  // 생략
  
  public void update(UserDto dto) {
    // 생략
    
    // 세컨더리 포트인 UserRepository Interface 의 메서드를 호출
    // 실제 처리는 세컨더리 어댑터가 수행
    userRepository.save(user);
  }

}
```

사용자 정보를 수정하는 update 메서드를 호출하는 클라이언트는 `프라이머리 어댑터`가 되고, update 메서드는 `프라이머리 포트`가 된다.

앞서 설명했던 계층형 아키텍처와의 차이점은 인터페이스를 이용해 의존관계를 관리한다는 점이다. __계층형 아키텍처에서는 논리적 계층만 분리되어있을 뿐 인터페이스를 사용할지 여부는 강제되지 않는다.__

그러나 실무에서는 계층형 아키텍처를 사용하더라도 대부분 인터페이스를 통한 의존관계 역전을 사용하기 때문에 양자 간의 실질적인 차이는 거의 없다.

### 클린 아키텍처

클린 아키텍처의 요점은 __비지니스 규칙을 캡슐화한 모듈을 중심에 두는 컨셉__ 이다. 클린 아키텍처의 `Entity` 는 우리가 배운 엔티티를 의미하지 않는다.

클린 아키텍처에서 말하는 엔티티는 비지니스 규칙을 `캡슐화한 객체` 혹은 `데이터 구조와 함수를 묶은 것`을 가리키는 것으로 굳이 따지면 우리가 배운 도메인 객체에 가까운 개념이다.

클린 아키텍처는 사용자 인터페이스나 데이터스토어 같은 세부사항은 가장자리로 밀어내고, 의존관계의 방향을 안쪽으로 향하게 함으로써 __세부사항이 추상에 의존하는 의존관계 역전 원칙__ 을 달성한다.

즉, 헥사고날 아키텍처와 목적하는 바가 같다.

헥사고날 아키텍처와 가장 큰 차이점은 구현 내용이 언급되는지 여부에 있다.

클린 아키텍처에는 `컨셉을 실현하기 위한 구체적인 구현 방식이 명시`된다.

- 속이 빈 화살표 : 추상화
  - `<I>` : 해당 모듈이 인터페이스임을 나타낸다.
- 일반적인 화살표 : 의존관계
- Flow of Control : 프로그램이 실행될 때의 제어 흐름을 의미한다.

## 정리

어느 아키텍처를 사용하든지 도메인 주도 설계에서 가장 중요한 것은 `도메인을 적절히 분리`하는 것이다. 모든 세부사항이 도메인에 의존하게 하면 소프트웨어의 주도권을 중요도가 높은
도메인이 쥐게할 수 있다.

굳이 위에서 소개한 아키텍처만 고집할 필요는 없다. 도메인을 적절히 분리할 수 있는 수단이라면 무엇이든 가져다 써도 된다.

__소프트웨어에서 가장 중요한 것은 사용자의 필요를 만족시키는 것과 문제를 해결하는 것이다.__ 이러한 본질에 집중할 수 있게 적절한 아키텍처를 선택하는 것이 중요하다.
