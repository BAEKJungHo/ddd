# 복잡한 조건을 나타내기 위한 명세

명세는 객체를 평가하기 위한 객체이다.

객체를 평가하기 위해 복잡한 절차가 필요한 경우가 있다. 이러한 절차를 해당 객체의 메서드로 정의하면 객체를 만든 취지가 잘 드러나지 않는다.

평가 절차를 객체로 정의하는 방법 외에 평가 자체를 별도의 객체로 분리할 수도 있따. 이렇게 별도의 객체로 분리하기 위한 조건을 가늠하는 역할을 맡는 객체가 바로 명세이다.

## 명세란 ?

객체를 평가하는 절차가 단순하면 객체의 메서드로 정의하면 되지만, 복잡한 경우나 자연스럽지 못한 경우가 있다. 결국 이러한 객체 평가 절차는 애플리케이션 서비스에 구현되기 마련인데,
객체에 대한 평가는 도메인 규칙중에서 중요도가 높기 때문에 서비스에 구현하는 것은 적합하지 않다.

이를 위해 사용하는 것이 명세이다. 

__즉, 어떤 객체가 그 객체의 평가 기준을 만족하는지 판정하기 위한 객체__ 이다.

예를 들어 서클의 최대 인원이 소속된 사용자에 따라 유형이 다음과 같이 바뀌는 경우가 있다.

- 사용자 중에는 프리미엄 사용자라는 유형이 존재한다.
- 서클의 최대 인원은 서클장과 소속 사용자를 포함해 30명이다.
- 프리미엄 사용자가 10명 이상 소속된 서클은 최대 인원이 50명으로 늘어난다.

위와 같은 `도메인 규칙`이 있으면 서비스가 아닌 `도메인 객체`에 정의 되어야 한다.

위 조건을 봐서는 데이터베이스 조회가 불가피 하다. 도메인에 정의할 경우 도메인 객체가 repository 에 의존하게 되는 현상이 발생한다.

## 명세

- 서클의 최대 인원에 여유가 있는지 확인하는 명세

```java
@RequiredArgsConstructor
@Component
public class CircleFullSpecification {
  private final UserRepository userRepository;
  
  // 아래 코드는 c#
  public boolean isSatisfiedBy(Circle circle) {
    var users = userRepository.find(circle.Members);
    var premiumUserNumber = users.Count(user => user.IsPremium);
    var circleUpperLimit = premiumUserNumber < 10 ? 30 : 50;
    return circle.CountMembers() >= circleUpperLimit;
  }
  
}
```

__명세는 해당 객체가 조건을 만족하는지 확인하는 역할만을 수행한다.__ 

- 명세를 사용하는 애플리케이션 서비스

```java
public class CircleApplicationService {
  private final CircleRepository circleRepository;
  private final CircleFullSpecification circleFullSpecification;
  
  // 생략
  
  public void join(CircleDto circleDto) {
    Circle circle = circleRepository.find(circleDto.getId());
    
    if(circleFullSpecification.isSatisfiedBy(circle)) {
      throw new CircleFullException(circle.getId()); 
    }
    
    // 생략
  }
  
}
```

복잡했던 객체 평가 코드를 캡슐화해 원래 객체의 의도를 잘 드러낼 수 있게 되었다.

### 의도가 잘 드러나지 않는 객체

도메인 객체에 객체 평가 메서드로 가득하다면, 나중에 변경이 닥쳤을때 어려움을 겪게 된다. 객체 평가가 단순하고 몇개 없다면 도메인 객체에 정의하면 된다.

만약, 객체 평가가 복잡하고 도메인 객체에 두기에 부자연스러운 경우에는 `명세`를 이용하면 된다.

## 일급 컬렉션을 이용해 리포지토리를 되도록 사용하지 않기

명세도 엄연한 도메인 객체이므로 내부에서 일어나는 입출력(리포지토리 사용)을 최대한 억제해야 한다는 의견도 있다. 이런 경우 `일급 컬렉션(first-class collection)`을 이용하는 방법도 있다.

> 일급 컬렉션(first-class collection)은 List 등의 제네릭 컬렉션 객체 대신 특화된 컬렉션 객체를 사용하는 패턴이다.

- 서클의 소속 사용자를 나타내는 일급 컬렉션 (c# 코드)

```java
public class CircleMember {
  private readonly User owner;
  private readonly List<User> members;
  
  public CircleMember(CircleId id, User owner, List<User> members) {
    Id = id;
    this.members = members;
  }
  
  public CircleId Id { get; }
  
  public int CountMembers() {
    return members.Count() + 1; 
  }
  
  public int CountPremiumMembers(bool containsOwner = true) {
    var premiumUserNumber = members.Count(member >= member.IsPreminum);
    if(containsOwner) {
      return premiumUserNumber + (owner.IsPremium ? 1 : 0); 
    } else {
      return premiumUserNumber; 
    }
  }
}
```

- 명세에서 일급 컬렉션 사용

```java
public boolean isSatisfiedBy(CircleMembers members) {
    var premiumUserNumber = members.CountPremiumMembers(false);
    var circleUpperLimit = premiumUserNumber < 10 ? 30 : 50;
    return members.CountMembers() >= circleUpperLimit;
}
```

- 애플리케이션 서비스 코드에서 일급 컬렉션 객체에 정보 주입하기

```java
var owner = userRepository.Find(circle.Member);
var members = userRepository.Find(circle.Members);
var cricleMembers = new CircleMembers(circle.Id, owner, members);
var circleFullSpec = new CircleMembersFullSpecification();
if(circleFullSpec.isSatisfiedBy(circleMembers)) {
  // 생략 
}
```

## 명세와 리포지토리 조합 

명세는 단독으로 사용하기도 하지만 리포지토리와 조합해서 사용할 수도 있다.
