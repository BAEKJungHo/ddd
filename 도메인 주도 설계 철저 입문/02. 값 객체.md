# 값 객체

도메인 주도 설계에서의 값 객체는 시스템 특유의 값을 나타내는 객체이다. JPA 의 값 객체와 유사하다.

주소를 예를 들면 다음과 같다.

```java
String address = "32051 서울시 강남구 blahblah";
```

여기서 우편번호만 출력한다고 해보자.

```java
String address = "32051 서울시 강남구 blahblah";
String[] addressToken = address.split(" ");
System.out.println(addressToken[3]);
```

우편번호는 첫 번째에 위치할 수도 있고 마지막에 위치할 수도 있다. 입력한 사람이나 시스템에 따라서 달라질 수 있다.

값 객체로 표현하면 다음과 같다.

```java
@Getter
private class Address {
  private String zipcode;
  private String city;
  private String street;
}
```

## 값의 성질

- 변하지 않는다.
- 주고받을 수 있다.
- 등가성을 비교할 수 있다.

### 불변성

값이 수정 가능하다면 안심하고 사용할 수 없다. 1이라는 숫자가 갑자기 0으로 바뀌면 혼란스러울 것이다.

값 클래스에서는 불변성을 유지하기 위해 `change()` 같은 메서드가 제공되서는 안된다.

불변 값 객체를 만들면 상태 변화를 막을 수 있다. 또한 컴퓨터의 메모리가 부족하다고 하면 `객체 캐싱`기능을 사용하여 완전히 같은 상태를 갖는 객체를 여러개 준비할 필요 없이 하나의 객체를
캐시로 돌려쓸 수 있어서 리소스를 절약할 수 있다.

### 교환 가능

- 값 객체의 수정 방식

```java
Address address = new Address("31052", "서울시", "강남구");
address = new Address("32082", "부산시", "서면");
```

### 등가성 비교

Address 내부에 equals 및 hashcode 를 구현했다면 두 객체는 같다고 판별될 것이다.

```java
Address address1 = new Address("31052", "서울시", "강남구");
Address address2 = new Address("32082", "부산시", "서면");
```

#### equals 와 hashcode

동일한 객체는 동일한 메모리 주소를 갖는다는 것을 의미하므로, 동일한 객체는 동일한 해시코드를 가져야 한다. 
그렇기 때문에 만약 우리가 equals() 메소드를 오버라이드 한다면, hashCode() 메소드도 오버라이드 되어야 한다.

- Java 프로그램을 실행하는 동안 equals에 사용된 정보가 수정되지 않았다면, hashCode는 항상 동일한 정수값을 반환해야 한다. (Java의 프로그램을 실행할 때 마다 달라지는 것은 상관이 없다.)
- 두 객체가 equals()에 의해 동일하다면, 두 객체의 hashCode() 값도 일치해야 한다.
- 두 객체가 equals()에 의해 동일하지 않다면, 두 객체의 hashCode() 값은 일치하지 않아도 된다.

## 값 객체가 되기 위한 기준

`규칙`이 존재하는가 아니면 `낱개`로 다루어야 하는가로 구분할 수있다.

주소, 핸드폰의 경우에는 규칙이 존재한다. 또한 낱개로도 이루어질수도 있다. 

이름, 주소, 핸드폰 등의 경우 시스템마다 특정한 규칙이 부여되기도 한다. 예를들어 주소에 대해서는 서울시만 저장 가능한다던지 등의 규칙이 있을 수 있다.

## 행동이 정의된 값 객체

값 객체에서 중요한 점 중 하나는 독자적인 행위를 정의할 수 있다는 점이다.

예를 들어, 돈의 경우 덧셈, 뺄셈이 가능하고 화폐 단위가 일치해야 한다.

그리고, 값 객체에 정의된 행위를 통해 이 객체가 어떤 역할을 하는지 알 수 있다. 즉, 정의 되지 않은 행위는 할 수 없다.

## 값 객체를 도입했을 때 장점

- 표현력이 증가한다.
- 무결성이 유지된다.
- 잘못된 대입을 방지한다.
- 로직이 코드 이곳저곳에 흩어지는 것을 방지한다.

### 표현력 증가

값 객체로 만듦 으로써 표현력이 증가한다.

### 무결성의 유지

주소의 경우 서울시만 받고, 우편번호의 길이는 6자이며 등의 규칙등을 통해서 값을 사용하기 전에 유효성을 체크할 수 있다.

> 즉, 값을 생성할때 생성자에서 유효성을 체크할 수 있다.

```java
public Address(String zipcode, String city, String street) {
  if(City.isNotSeoul(city)) {
    throw new IllegalArgumentException("서울시만 올 수 있습니다.");
  }
  if(zipcode.length() != 6) {
    throw new IllegalArgumentException("우편번호는 6자리여야 합니다.");
  }
}
```

### 잘 못된 값 대입 방지

```java
@Getter
public class User {
  // String city; // 이 경우 도시에 우편번호를 입력해도 방지할 길이 없다.
  private Address address; // 값 객체를 사용함으로써 값 객체 생성 시 유효성 검사를 통해 잘못된 값을 방지할 수 있다.
}
```

### 로직을 한곳에 모아두기

DRY 원칙에 나와있듯이 코드 중복을 방지하는 일은 매우 중요하다.

값 객체를 이용해 주소 혹은 사용자이름 같은 규칙에 관한 로직을 한곳에 모아 둘 수 있다.

## 정리

값 객체를 잘 정의하면 코드 자체가 문서의 역할을 할 수 있다. 시스템의 명세는 보통 문서로 저장되는데 그 문서 역할을 코드가 담당한다면, 번거로움을 덜 수 있다.

값 객체는 도메인 지식을 코드로 녹여내는 도메인 주도 설계의 기본 패턴이다.

