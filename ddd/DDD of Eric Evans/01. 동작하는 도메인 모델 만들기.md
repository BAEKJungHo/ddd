# 동작하는 도메인 모델 만들기

소프트웨어 도메인이란 사용자가 프로그램을 사용하는 대상 영역을 의미한다. 예를들어 회계 프로그램에서는 화폐와 금융이 도메인에 해당된다.

## 도메인 주도 설계에서의 모델의 유용성

도메인 주도 설계에서는 아래의 세 가지 기본적인 쓰임새에 따라 모델을 선택한다. 

- 모델과 핵심 설계는 서로 영향을 주며 구체화된다.
- 모델은 모든 팀 구성원이 사용하는 언어의 중추다.
- 모델은 지식의 정수만을 뽑아낸 것이다.

## 소프트웨어의 본질

소프트웨어의 본질은 사용자를 위해 도메인에 관련된 문제를 해결하는 능력에 있다. 하지만 대부분 유능한 개발자들은 다뤄야 할 특정 도메인을 학습하는데 관심이 많지 않으며, 더군다나 도메인 모델링
기법을 쌓는 데는 더더욱 전념하지 않는다. 기술자들은 자신의 기술력을 훈련할 수 있는 정량적인 문제를 좋아한다.

## 효과적인 모델링의 요소

1. 모델과 구현의 연계
2. 모델을 기반으로 하는 언어 정제
3. 풍부한 지식이 담긴 모델 개발
4. 모델의 정제
5. 브레인스토밍과 실험

## 지속적인 학습

소프트웨어를 작성하기 시작할 때 우리는 충분히 알지 못한 상태에서 시작한다. 

생산성이 매우 뛰어난 팀은 `지속적인 학습`을 바탕으로 의식적으로 지식을 함양한다. 개발자에게는 이것이 일반적인 도메인 모델링 기술과 기술적 지식이 모두 향상된다는 것을 의미한다.

## 정책(policy)

예를들어, 선박 화물의 운송 예약을 위한 애플리케이션을 만든다고 하자. 

도메인 규칙 중에는 다음이 있다.

- 10% 초과예약 허용

이러한 규칙을 적용하여 `메서드 보호절(guard clause)`로 빼내면 다음과 같다.

```java
public int makeBooking(Cargo cargo, Voyage voyage) {
  double maxBooking = voyage.capacity() * 1.1;
  if((voyage.bookedCargoSize() + cargo.size()) > maxBooking) {
    return -1;
  }
  // 생략
}
```

위 코드의 문제는 도메인 전문가가 봤을 때 이 코드를 읽고 규칙을 검증하지 못할 것이다. 또한 규칙이 좀 더 복잡했다면 문제가 훨씬 더 심각해 질 것이다.

이러한 코드를 `정책(policy)`을 이용하여 리팩터링 할 수 있다.

```java
public class OverbookingPolicy {
  
  // 생략
  
  public boolean isAllowed(Cargo cargo, Voyage voyage) {
    return (cargo.size() + voyage.bookedCargoSize()) <= (voyage.capacity() * 1.1);
  }

}
```

이렇게하면 초과예약이 별개의 정책이라는 사실을 모든 이가 분명히 알게 될 것이며, 이 규칙의 구현 또한 명시적으로 드러나고 다른 구현과 분리된다.

도메인의 모든 세부 사항에 이러한 정교한 설계를 적용하라고 권장하는 것은 아니다. 
