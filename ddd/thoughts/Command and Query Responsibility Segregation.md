# CQRS(Command and Query Responsibility Segregation)

SI 에서 일할때, `순환참조` 문제를 겪은 적이 있다. A service 에서 B service 를 의존하고, B 에서는 A 를 의존하여 발생했던 문제인데,
A 에서는 B 에 있는 조회를 사용하고, B 에서 등록할때 A 도 같이 등록하는 경우 였던것 같다.

이러한 순환참조는 보통 `설계가 잘 못되었을때 발생`하는데, 가장 좋은 방법은 설계를 다시 하는 것이다. 그리고 설계할때 CQRS 를 적용하면 순환참조 발생 가능성이 낮아진다.

즉, 명령과 쿼리를 분리하는 것이다. A service 에서는 B service 의 명령 작업이 필요없는데 굳이 A service 에서 B 의 명령 함수들 까지 노출시킬 필요가 없기 때문이다.

또한 명령과 쿼리를 분리한 서비스에서 트랜잭션 기본 설정을 다음과 같이 할 수 있다.

- 명령은 `@Transcational`
- 쿼리는 `@Transactional(readOnly = true)` 

일반적으로 도메인 또는 비지니스로직이 간단한 경우 데이터베이스를 쿼리하고 업데이트하는 데 동일한 모델을 사용한다. 하지만, 애플리케이션이 복잡한 경우 이 방법을 사용하기 어려울 수 있다.
예를 들어 읽기 쪽에서 다른 쿼리를 수행할 수 있고 모양이 다른 `DTO` 를 반환한다. 모델은 쓰기 쪽에서 복잡한 유효성 검사 및 비지니스 로직을 구현할 수 있다.

__읽기 및 쓰기 작업은 매우 다양한 성능 및 확장 요구 사항을 가진 비대칭인 경우가 많다.__

CQRS 는 읽기 쓰기 표현이 일치하지 않고 복잡한 경우나, 읽기 쿼리가 복잡하여 성능 문제가 우려되는 경우 (Ex. 페이징) 읽기 쿼리후 엔티티의 불필요한 데이터를 노출 시킬 위험이 있는 경우에 사용하면 좋다. __읽기 모델에는 비즈니스 논리 또는 유효성 검사 스택이 없으며 뷰 모델에서 사용할 DTO 를 반환 한다.__ 결과적으로 읽기 모델과 쓰기 모델의 일관성이 유지된다.

> 즉, CQRS 패턴을 적용하게 되면 자연스레 엔티티나 도메인 서비스등에 도메인 로직이 집중되며, DTO 는 도메인 모델을 캡슐화하지 않아야 하므로 비지니스 규칙이나 유효성 검사 스택이 존재해서는 안 된다. 따라서 프레젠테이션 계층에서 목록, View, 수정페이지의 경우에는 읽기 모델인, DTO 난 Form 객체를 만들어 사용하고 명령 작업 시에는 유효성 검사 스택이랑 도메인 로직이 들어있는 엔티티를 사용한다.
> 
> DTO 에서 toEntity 메서드를 갖는 경우, 보통 Controller 에서 cud 를 처리하는 메서드에서 DTO 를 파라미터로 받게 되는데, 그러면 자연스레 DTO 에 유효성 검사 스택이 들어가게 되고, 도메인 로직이 DTO 에 들어갈 가능성이 있다고 생각 함. 
> 
> 즉, 읽기 작업후 데이터 반환은 DTO 를 사용하며, 유효성 검사가 필요한 쓰기 작업의 경우 ENTITY 를 WRITE MODEL 로 쓰는것이 바람직 하지 않나 생각 함.

CQRS 의 특징은 다음과 같다.

- 명령은 데이터 중심이 아닌 `작업 기반`이어야 한다.
- 쿼리는 데이터베이스를 수정하지 않고, `도메인 정보를 캡슐화 하지 않는 DTO 를 반환`한다.
  - API 요청을 처리할 때, 엔티티가 아닌 DTO 를 반환해야 하는데, 예를 들어 엔티티에 비밀번호 필드가 있을 경우 해당 비밀번호가 응답에 노출될 가능성도 있으며, API 명세가 바뀌게 되면 엔티티도 변해야 하는 불상사가 발생할 수 있다. 

즉, CQRS 는 `WRITE MODEL` 과 `READ MODEL`이 다른데, WRITE MODEL 은 보통 `ENTITY`를 의미하며, READ MODEL 은 `DTO` 를 의미한다.

## 가맹점 신청 개발 문제 

최근에 DDD 를 공부하고 가맹점 신청 개발건에 DDD 개념을 적용하여 개발을 하였는데, 첫 시도이고 공부가 제대로 안 됬던 탓인지 다음과 같은 문제가 발생했다.

1. 프레젠테이션 계층에서 CRUD 작업을 모두 DTO 를 파라미터로 받아서 사용 DTO 자체에 유효성 검사 스택이 들어가있고, 도메인 로직이 들어가 있음.
2. VALIDATOR 에도 도메인 로직이 들어가 있음.
3. 패키지 구분을 DOMAIN 패키지 아래에 DTO 를 만들어서 사용했음.

도메인 로직이 엔티티나 명세에 모여있지 않고 여러 군데 흩어져서 응집도가 낮아지고 도메인 분석이 어려워짐.

따라서 아래와 같이 리팩토링을 실시 하였다.

- REFACTORING

1. READ 작업에는 DTO 를 파라미터로 사용(즉, 읽기 작업 후 데이터 반환 시에는 DTO 사용)
2. CUD 작업에는 데이터 반환이 필요없으므로 유효성 검사와 도메인 로직이 들어있는 ENTITY 사용
3. DTO 패키지를 WEB 아래로 이동

## References

> [복잡한 쿼리는 리드모델로](https://github.com/BAEKJungHo/driven/blob/main/ddd/%EB%8F%84%EB%A9%94%EC%9D%B8%20%EC%A3%BC%EB%8F%84%20%EC%84%A4%EA%B3%84%20%EC%B2%A0%EC%A0%80%20%EC%9E%85%EB%AC%B8/13.%20%EB%AA%85%EC%84%B8(Specification).md#%EB%B3%B5%EC%9E%A1%ED%95%9C-%EC%BF%BC%EB%A6%AC%EB%8A%94-%EB%A6%AC%EB%93%9C%EB%AA%A8%EB%8D%B8%EB%A1%9C)
>
> [CQRS](https://docs.microsoft.com/ko-kr/azure/architecture/patterns/cqrs)
